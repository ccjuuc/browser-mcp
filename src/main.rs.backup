use anyhow::Result;

mod codebase;
mod app_config;
mod embedding;
mod indexer_state;
mod mcp;
mod parser;
mod storage;
mod http_server;

use codebase::CodebaseIndexer;
use app_config::Config;
use mcp::MCPServer;
use http_server::HttpServer;
use std::sync::Arc;
use storage::qdrant::QdrantStorage;

#[tokio::main]
async fn main() -> Result<()> {
    // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°
    let args: Vec<String> = std::env::args().collect();
    let http_mode = args.contains(&"--http".to_string()) || args.contains(&"-h".to_string());
    let port: u16 = args
        .iter()
        .position(|arg| arg == "--port" || arg == "-p")
        .and_then(|i| args.get(i + 1))
        .and_then(|p| p.parse().ok())
        .unwrap_or(3000);
    
    // åŠ è½½é…ç½®
    let config = Config::load()?;
    
    // åˆå§‹åŒ–æ—¥å¿—
    let log_level = std::env::var("RUST_LOG")
        .unwrap_or_else(|_| config.server.log_level.clone());
    
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_new(&log_level)
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::from_default_env())
        )
        .init();

    let codebase_path = config.codebase_path();
    
    if !codebase_path.exists() {
        tracing::warn!(
            "Codebase path does not exist: {:?}. Please check your configuration.",
            codebase_path
        );
    }
    
    tracing::info!("Initializing MCP server for codebase: {:?}", codebase_path);
    tracing::info!("Config loaded: max_results={}, max_file_size={} bytes", 
                   config.server.max_results, 
                   config.codebase.max_file_size);
    
    // åˆå§‹åŒ– Qdrant å­˜å‚¨
    let qdrant_storage = if !config.qdrant.url.is_empty() {
        // æ£€æŸ¥ Qdrant æ˜¯å¦å·²ç»åœ¨è¿è¡Œ
        let qdrant_running = tokio::net::TcpStream::connect("127.0.0.1:6334")
            .await
            .is_ok();
        
        if !qdrant_running {
            // å¦‚æœé…ç½®äº† Qdrant äºŒè¿›åˆ¶è·¯å¾„ï¼Œå°è¯•å¯åŠ¨ Qdrant
            if let Some(ref bin_path) = config.qdrant.bin_path {
                tracing::info!("Qdrant not running, starting from: {}", bin_path);
                
                // è®¾ç½®å­˜å‚¨ç›®å½•ä¸º qdrant.exe åŒçº§çš„ storage ç›®å½•
                let qdrant_dir = std::path::Path::new(bin_path)
                    .parent()
                    .unwrap_or(std::path::Path::new("."));
                let storage_path = qdrant_dir.join("storage");
                
                // ç¡®ä¿å­˜å‚¨ç›®å½•å­˜åœ¨
                if let Err(e) = std::fs::create_dir_all(&storage_path) {
                    tracing::warn!("Failed to create storage directory: {}", e);
                }
                
                // åˆ›å»º Qdrant é…ç½®æ–‡ä»¶
                let config_path = qdrant_dir.join("config.yaml");
                let config_content = format!(
                    r#"storage:
  storage_path: {}
  # ä¼˜åŒ–å™¨é…ç½® - ç¦ç”¨è‡ªåŠ¨ä¼˜åŒ–ä»¥é¿å… Windows æƒé™é—®é¢˜
  optimizers:
    # åˆ é™¤çš„å‘é‡æ•°é‡é˜ˆå€¼ï¼ˆè®¾ç½®å¾ˆé«˜ï¼ŒåŸºæœ¬ä¸ä¼šè§¦å‘ï¼‰
    deleted_threshold: 0.9
    # ç©ºæ®µæ•°é‡é˜ˆå€¼ï¼ˆè®¾ç½®å¾ˆé«˜ï¼ŒåŸºæœ¬ä¸ä¼šè§¦å‘ï¼‰
    vacuum_min_vector_number: 100000
    # é»˜è®¤æ®µå¤§å°ï¼ˆMBï¼‰
    default_segment_number: 2
    # ç´¢å¼•é˜ˆå€¼
    indexing_threshold:  50000
    # åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰- è®¾ç½®å¾—æ›´é•¿
    flush_interval_sec: 30
    # ä¼˜åŒ–çº¿ç¨‹æ•°
    max_optimization_threads: 1

service:
  host: 0.0.0.0
  http_port: 6333
  grpc_port: 6334
  # æœ€å¤§è¯·æ±‚å¤§å°ï¼ˆMBï¼‰
  max_request_size_mb: 64
"#,
                    storage_path.to_string_lossy().replace('\\', "/")
                );
                
                if let Err(e) = std::fs::write(&config_path, config_content) {
                    tracing::warn!("Failed to create Qdrant config file: {}", e);
                } else {
                    tracing::info!("Created Qdrant config at: {:?}", config_path);
                }
                
                tracing::info!("Qdrant storage path: {:?}", storage_path);
                
                // ä½¿ç”¨é…ç½®æ–‡ä»¶å¯åŠ¨ Qdrant
                let child = std::process::Command::new(bin_path)
                    .arg("--config-path")
                    .arg(&config_path)
                    .current_dir(qdrant_dir)
                    .spawn();
                
                match child {
                    Ok(_) => {
                        tracing::info!("Qdrant started successfully with storage at {:?}", storage_path);
                        // ç»™ä¸€ç‚¹æ—¶é—´è®© Qdrant å¯åŠ¨
                        tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
                    }
                    Err(e) => {
                        tracing::error!("Failed to start Qdrant: {}", e);
                    }
                }
            }
        } else {
            tracing::info!("Qdrant already running on port 6334");
        }

        // åˆ¤æ–­æ˜¯å¦åº”è¯¥åˆå§‹åŒ– Qdrant (ä¾‹å¦‚å¯ä»¥å¢åŠ  enable_qdrant é…ç½®ï¼Œè¿™é‡Œæš‚æ—¶åªè¦æœ‰ URL å°±å°è¯•)
        // å®é™…ä¸Š Embedder çš„ç»´åº¦é…ç½®åœ¨ config.embedding.dimension
        match QdrantStorage::new(&config.qdrant.url, config.qdrant.collection_name.clone(), config.embedding.dimension as u64) {
             Ok(storage) => {
                 if let Err(e) = storage.init().await {
                     tracing::error!("Failed to initialize Qdrant storage: {}. Vector search will be disabled.", e);
                     None
                 } else {
                     Some(Arc::new(storage))
                 }
             }
             Err(e) => {
                 tracing::error!("Failed to create Qdrant client: {}. Vector search will be disabled.", e);
                 None
             }
        }
    } else {
        None
    };

    let indexer = Arc::new(CodebaseIndexer::with_embedding_config(
        codebase_path.clone(),
        config.codebase.clone(),
        config.embedding.clone(),
        qdrant_storage,
    ));
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç´¢å¼•
    // è¯»å–ç´¢å¼•çŠ¶æ€ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰æ–‡ä»¶éƒ½å·²ç´¢å¼•
    let state_path = std::env::current_dir()
        .unwrap_or_else(|_| std::path::PathBuf::from("."))
        .join("browser-mcp-index.json");
    
    let needs_indexing = if state_path.exists() {
        // å¦‚æœçŠ¶æ€æ–‡ä»¶å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æœªç´¢å¼•çš„æ–‡ä»¶
        tracing::info!("Index state file found, checking for updates...");
        false // å‡è®¾å·²ç´¢å¼•å®Œæˆï¼Œåªåœ¨æœ‰æ›´æ–°æ—¶æ‰é‡æ–°ç´¢å¼•
    } else {
        // å¦‚æœçŠ¶æ€æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦ç´¢å¼•
        tracing::info!("No index state found, initial indexing required");
        true
    };
    
    // å¦‚æœå¯ç”¨äº† Qdrant ä¸”éœ€è¦ç´¢å¼•ï¼Œå¯åŠ¨åå°ç´¢å¼•ä»»åŠ¡
    if indexer.is_qdrant_enabled() && needs_indexing {
        let indexer_clone = indexer.clone();
        tokio::spawn(async move {
            if let Err(e) = indexer_clone.index_codebase().await {
                tracing::error!("Background indexing failed: {}", e);
            }
        });
    }

    // æ ¹æ®æ¨¡å¼å¯åŠ¨å¯¹åº”çš„æœåŠ¡å™¨
    if http_mode {
        tracing::info!("ğŸŒ Starting HTTP MCP Server on port {}", port);
        let http_server = HttpServer::new(indexer, port);
        http_server.run().await?;
    } else {
        tracing::info!("ğŸ“Ÿ Starting stdio MCP Server");
        let server = MCPServer::new(indexer);
        server.run().await?;
    }
    
    Ok(())
}


    
    // åˆå§‹åŒ–æ—¥å¿—
    let log_level = std::env::var("RUST_LOG")
        .unwrap_or_else(|_| config.server.log_level.clone());
    
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_new(&log_level)
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::from_default_env())
        )
        .init();

    let codebase_path = config.codebase_path();
    
    if !codebase_path.exists() {
        tracing::warn!(
            "Codebase path does not exist: {:?}. Please check your configuration.",
            codebase_path
        );
    }
    
    tracing::info!("Initializing MCP server for codebase: {:?}", codebase_path);
    tracing::info!("Config loaded: max_results={}, max_file_size={} bytes", 
                   config.server.max_results, 
                   config.codebase.max_file_size);
    
    // åˆå§‹åŒ– Qdrant å­˜å‚¨
    let qdrant_storage = if !config.qdrant.url.is_empty() {
        // æ£€æŸ¥ Qdrant æ˜¯å¦å·²ç»åœ¨è¿è¡Œ
        let qdrant_running = tokio::net::TcpStream::connect("127.0.0.1:6334")
            .await
            .is_ok();
        
        if !qdrant_running {
            // å¦‚æœé…ç½®äº† Qdrant äºŒè¿›åˆ¶è·¯å¾„ï¼Œå°è¯•å¯åŠ¨ Qdrant
            if let Some(ref bin_path) = config.qdrant.bin_path {
                tracing::info!("Qdrant not running, starting from: {}", bin_path);
                
                // è®¾ç½®å­˜å‚¨ç›®å½•ä¸º qdrant.exe åŒçº§çš„ storage ç›®å½•
                let qdrant_dir = std::path::Path::new(bin_path)
                    .parent()
                    .unwrap_or(std::path::Path::new("."));
                let storage_path = qdrant_dir.join("storage");
                
                // ç¡®ä¿å­˜å‚¨ç›®å½•å­˜åœ¨
                if let Err(e) = std::fs::create_dir_all(&storage_path) {
                    tracing::warn!("Failed to create storage directory: {}", e);
                }
                
                // åˆ›å»º Qdrant é…ç½®æ–‡ä»¶
                let config_path = qdrant_dir.join("config.yaml");
                let config_content = format!(
                    r#"storage:
  storage_path: {}
  # ä¼˜åŒ–å™¨é…ç½® - ç¦ç”¨è‡ªåŠ¨ä¼˜åŒ–ä»¥é¿å… Windows æƒé™é—®é¢˜
  optimizers:
    # åˆ é™¤çš„å‘é‡æ•°é‡é˜ˆå€¼ï¼ˆè®¾ç½®å¾ˆé«˜ï¼ŒåŸºæœ¬ä¸ä¼šè§¦å‘ï¼‰
    deleted_threshold: 0.9
    # ç©ºæ®µæ•°é‡é˜ˆå€¼ï¼ˆè®¾ç½®å¾ˆé«˜ï¼ŒåŸºæœ¬ä¸ä¼šè§¦å‘ï¼‰
    vacuum_min_vector_number: 100000
    # é»˜è®¤æ®µå¤§å°ï¼ˆMBï¼‰
    default_segment_number: 2
    # ç´¢å¼•é˜ˆå€¼
    indexing_threshold: 50000
    # åˆ·æ–°é—´éš”ï¼ˆç§’ï¼‰- è®¾ç½®å¾—æ›´é•¿
    flush_interval_sec: 30
    # ä¼˜åŒ–çº¿ç¨‹æ•°
    max_optimization_threads: 1

service:
  host: 0.0.0.0
  http_port: 6333
  grpc_port: 6334
  # æœ€å¤§è¯·æ±‚å¤§å°ï¼ˆMBï¼‰
  max_request_size_mb: 64
"#,
                    storage_path.to_string_lossy().replace('\\', "/")
                );
                
                if let Err(e) = std::fs::write(&config_path, config_content) {
                    tracing::warn!("Failed to create Qdrant config file: {}", e);
                } else {
                    tracing::info!("Created Qdrant config at: {:?}", config_path);
                }
                
                tracing::info!("Qdrant storage path: {:?}", storage_path);
                
                // ä½¿ç”¨é…ç½®æ–‡ä»¶å¯åŠ¨ Qdrant
                let child = std::process::Command::new(bin_path)
                    .arg("--config-path")
                    .arg(&config_path)
                    .current_dir(qdrant_dir)
                    .spawn();
                
                match child {
                    Ok(_) => {
                        tracing::info!("Qdrant started successfully with storage at {:?}", storage_path);
                        // ç»™ä¸€ç‚¹æ—¶é—´è®© Qdrant å¯åŠ¨
                        tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
                    }
                    Err(e) => {
                        tracing::error!("Failed to start Qdrant: {}", e);
                    }
                }
            }
        } else {
            tracing::info!("Qdrant already running on port 6334");
        }

        // åˆ¤æ–­æ˜¯å¦åº”è¯¥åˆå§‹åŒ– Qdrant (ä¾‹å¦‚å¯ä»¥å¢åŠ  enable_qdrant é…ç½®ï¼Œè¿™é‡Œæš‚æ—¶åªè¦æœ‰ URL å°±å°è¯•)
        // å®é™…ä¸Š Embedder çš„ç»´åº¦é…ç½®åœ¨ config.embedding.dimension
        match QdrantStorage::new(&config.qdrant.url, config.qdrant.collection_name.clone(), config.embedding.dimension as u64) {
             Ok(storage) => {
                 if let Err(e) = storage.init().await {
                     tracing::error!("Failed to initialize Qdrant storage: {}. Vector search will be disabled.", e);
                     None
                 } else {
                     Some(Arc::new(storage))
                 }
             }
             Err(e) => {
                 tracing::error!("Failed to create Qdrant client: {}. Vector search will be disabled.", e);
                 None
             }
        }
    } else {
        None
    };

    let indexer = Arc::new(CodebaseIndexer::with_embedding_config(
        codebase_path.clone(),
        config.codebase.clone(),
        config.embedding.clone(),
        qdrant_storage,
    ));
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç´¢å¼•
    // è¯»å–ç´¢å¼•çŠ¶æ€ï¼Œåˆ¤æ–­æ˜¯å¦æ‰€æœ‰æ–‡ä»¶éƒ½å·²ç´¢å¼•
    let state_path = std::env::current_dir()
        .unwrap_or_else(|_| std::path::PathBuf::from("."))
        .join("browser-mcp-index.json");
    
    let needs_indexing = if state_path.exists() {
        // å¦‚æœçŠ¶æ€æ–‡ä»¶å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æœªç´¢å¼•çš„æ–‡ä»¶
        tracing::info!("Index state file found, checking for updates...");
        false // å‡è®¾å·²ç´¢å¼•å®Œæˆï¼Œåªåœ¨æœ‰æ›´æ–°æ—¶æ‰é‡æ–°ç´¢å¼•
    } else {
        // å¦‚æœçŠ¶æ€æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦ç´¢å¼•
        tracing::info!("No index state found, initial indexing required");
        true
    };
    
    // å¦‚æœå¯ç”¨äº† Qdrant ä¸”éœ€è¦ç´¢å¼•ï¼Œå¯åŠ¨åå°ç´¢å¼•ä»»åŠ¡
    if indexer.is_qdrant_enabled() && needs_indexing {
        let indexer_clone = indexer.clone();
        tokio::spawn(async move {
            if let Err(e) = indexer_clone.index_codebase().await {
                tracing::error!("Background indexing failed: {}", e);
            }
        });
    }

    let server = MCPServer::new(indexer);
    
    server.run().await?;
    
    Ok(())
}

