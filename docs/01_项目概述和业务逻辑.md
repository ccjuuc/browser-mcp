# Browser MCP Server - 项目概述和业务逻辑

## 1. 项目简介

Browser MCP Server 是一个基于 MCP (Model Context Protocol) 协议的代码库索引和搜索服务器。它的核心目标是帮助 AI 助手（如 Claude Desktop、Cursor 等）高效地访问、搜索和理解大型代码库（如 Brave Browser 源码）。

## 2. 项目背景和解决的问题

### 2.1 核心问题

在 AI 辅助编程的场景中，AI 助手需要能够：
- **快速定位代码**：根据用户需求找到相关代码片段
- **理解代码语义**：不仅匹配文本，还要理解代码的功能和意图
- **处理大型代码库**：Brave Browser 等大型项目包含数万甚至数十万个文件
- **实时响应**：搜索结果需要在秒级内返回

### 2.2 传统方案的局限性

- **纯文本搜索**：只能匹配关键词，无法理解语义
- **线性扫描**：遍历所有文件速度慢，无法处理大型代码库
- **缺乏上下文**：返回的代码片段缺少语义信息

## 3. 业务逻辑概述

### 3.1 核心业务流程

```
代码库 → 文件扫描 → 代码解析 → 代码切片 → 向量化 → 存储到向量数据库 → 语义搜索
```

### 3.2 主要功能模块

#### 3.2.1 代码索引（Indexing）

**目标**：将代码库中的所有源代码转换为可搜索的向量表示

**流程**：
1. **文件发现**：遍历代码库目录，识别源代码文件
2. **文件过滤**：
   - 跳过二进制文件（图片、字体、编译产物等）
   - 跳过超过大小限制的文件（默认 1MB）
   - 尊重 `.gitignore` 规则
3. **代码解析**：使用 Tree-sitter 解析代码，提取语法结构
4. **代码切片**：将代码按语义单元（函数、类、方法等）切分成块
5. **向量化**：为每个代码块生成向量嵌入（Embedding）
6. **存储**：将代码块和向量存储到 Qdrant 向量数据库

**关键设计**：
- **增量索引**：只处理新增或修改的文件，提高效率
- **状态跟踪**：记录每个文件的修改时间和大小，跳过未变更文件

#### 3.2.2 文本搜索（Text Search）

**目标**：基于关键词和模式匹配搜索代码

**实现方式**：
- 使用正则表达式进行文本匹配
- 遍历代码库中的文件（支持 `.gitignore`）
- 返回匹配的行和上下文

**适用场景**：
- 搜索函数名、变量名等精确匹配
- 查找特定的字符串或模式
- 快速定位已知的代码位置

#### 3.2.3 语义搜索（Semantic Search）

**目标**：基于代码的语义和功能进行搜索

**实现方式**：
1. 将用户查询转换为向量
2. 在向量数据库中搜索相似度最高的代码块
3. 使用余弦相似度计算相似性
4. 返回最相关的代码片段

**适用场景**：
- "如何实现视频解码？"
- "查找处理用户认证的代码"
- "找到所有处理错误的函数"

#### 3.2.4 文件浏览（File Browsing）

**功能**：
- 列出指定目录下的文件和子目录
- 读取文件内容
- 支持相对路径和绝对路径

## 4. 数据模型

### 4.1 代码块（CodeChunk）

代码切片的基本单元，包含：

```rust
pub struct CodeChunk {
    pub file_path: String,        // 文件路径
    pub language: String,          // 编程语言
    pub content: String,           // 代码内容
    pub start_line: usize,         // 起始行号
    pub end_line: usize,           // 结束行号
    pub start_byte: usize,         // 起始字节位置
    pub end_byte: usize,           // 结束字节位置
    pub node_type: String,         // 节点类型（function, class等）
    pub node_name: Option<String>, // 节点名称（函数名、类名等）
    pub embedding: Option<Vec<f32>>, // 向量嵌入（可选）
}
```

### 4.2 索引状态（IndexerState）

跟踪已索引文件的状态：

```rust
pub struct IndexerState {
    pub file_states: HashMap<String, FileState>, // 文件路径 -> 文件状态
}

pub struct FileState {
    pub last_modified: u64, // 最后修改时间（Unix 时间戳）
    pub size: u64,          // 文件大小（字节）
}
```

## 5. 关键业务决策

### 5.1 为什么使用 Tree-sitter？

- **语义感知**：理解代码结构，而不是简单的文本切割
- **多语言支持**：统一的接口支持多种编程语言
- **增量解析**：支持增量更新，性能好

### 5.2 为什么使用向量数据库？

- **快速相似度搜索**：向量数据库专门优化了相似度搜索
- **可扩展性**：可以处理数百万个向量
- **高效存储**：Qdrant 提供压缩和索引优化

### 5.3 为什么支持 TF-IDF 降级？

- **无需模型**：在没有 GPU 或模型文件的情况下也能工作
- **快速启动**：不需要加载大模型
- **资源友好**：内存占用小

### 5.4 为什么使用增量索引？

- **性能优化**：只处理变更的文件
- **节省资源**：避免重复处理未修改的文件
- **实时更新**：新文件可以快速被索引

## 6. 工作流程示例

### 6.1 首次索引流程

```
1. 用户启动服务器，配置代码库路径
2. 服务器检查 Qdrant 是否可用
3. 如果可用，启动后台索引任务
4. 遍历代码库所有文件
5. 对每个源代码文件：
   a. 使用 Tree-sitter 解析
   b. 提取函数、类等语义单元
   c. 将代码块向量化
   d. 存储到 Qdrant
6. 保存索引状态到 browser-mcp-index.json
```

### 6.2 搜索流程

**文本搜索**：
```
1. 用户提交搜索查询
2. 使用正则表达式匹配
3. 遍历文件，查找匹配行
4. 返回结果（包含文件路径、行号、上下文）
```

**语义搜索**：
```
1. 用户提交自然语言查询
2. 将查询转换为向量（使用 Embedder）
3. 在 Qdrant 中搜索最相似的向量
4. 按相似度排序
5. 返回代码块和相似度分数
```

### 6.3 增量更新流程

```
1. 服务器启动时加载索引状态
2. 扫描代码库文件
3. 对于每个文件：
   a. 检查是否已在索引状态中
   b. 比较修改时间和文件大小
   c. 如果未变化，跳过
   d. 如果变化，重新索引
4. 更新索引状态
```

## 7. 性能和扩展性考虑

### 7.1 性能优化

- **异步 I/O**：使用 Tokio 异步运行时，提高并发性能
- **增量索引**：只处理变更文件
- **批量处理**：向量化时批量处理多个代码块
- **智能过滤**：跳过二进制文件和大文件

### 7.2 扩展性

- **水平扩展**：Qdrant 支持集群部署
- **模块化设计**：各个组件可以独立优化
- **可配置**：通过配置文件调整性能参数

## 8. 安全性考虑

### 8.1 路径安全

- 所有文件路径都进行验证，确保在代码库目录内
- 防止路径遍历攻击

### 8.2 资源限制

- 限制文件大小（默认 1MB）
- 限制搜索结果显示数量
- 跳过可能危险的二进制文件

### 8.3 数据隐私

- 所有数据本地存储
- 不向外部服务发送代码内容
- 支持本地模型推理（可选）

## 9. 总结

Browser MCP Server 通过结合传统文本搜索和现代语义搜索技术，为 AI 助手提供了强大的代码库访问能力。其核心优势在于：

1. **语义理解**：使用向量嵌入理解代码语义
2. **高性能**：增量索引和向量数据库提供快速搜索
3. **易用性**：支持多种搜索方式，满足不同场景需求
4. **可扩展**：模块化设计，易于扩展和维护

